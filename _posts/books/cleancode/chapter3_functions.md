### 3장 함수 (Functions)

> 어떤 프로그램이든 가장 기본적인 단위가 함수다.

> 의도를 분명히 표현하는 함수를 어떻게 구현할 수 있을까? 함수에 어떤 속성을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있을까?
<br>

<br>

#### 작게 만들어라!

> 함수를 만드는 첫째 규칙은 '작게!'다.<br>
> 지금까지 경험을 바탕으로 그리고 오랜 시행착오를 바탕으로 나는 작은 함수가 좋다고 확신한다.

> 각 함수가 너무도 명백했다. 각 함수가 이야기 하나를 표현했다. 각 함수가 너무도 멋지게 다음 무대를 준비했다. 이것이 바로 답이다!

[블록과 들여쓰기]
> 다시 말해, if 문/else 문/while 문 등에 들어가는 블록은 한 줄이어야 한다는 의미다. 대게 거기서 함수를 호출한다. 그러면 바깥을 감싸는 함수(enclosing function)가 작아질 뿐 아니라,
> 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워진다.

> 이 말은 중첩 구조가 생길만큼 함수가 커져서는 안된다는 뜻이다. 그러므로 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다. 당연한 말이지만, 그래야 함수는 읽고 이해하기 쉬워진다.

#### 한 가지만 해라!

> 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.

> 문제라면 그 '한 가지'가 무엇인지 알기가 어렵다는 점이다.

> 언급하는 세 단계는 지정된 함수 이름 아래에서 추상화 수준이 하나다.

> 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다. 어쨌거나 우리가 함수를 만드는 이유는 큰 개념을 (다시 말해, 함수 이름을) 다음 추상화 수준에서 여러 단계로
> 나눠 수행하기 위해서가 아니던가.

> 따라서, 함수가 '한 가지'만 하는지 판단하는 방법이 하나 더 있다. 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.

[함수 내 섹션]
> 한 가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.

<br>

#### 함수 당 추상화 수준은 하나로!

> 함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.

> 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어려운 탓이다. <br>
> 근본 개념과 세부사항을 뒤섞기 시작하면, 깨어진 창문처럼 사람들이 함수에 세부사항을 점점 더 추가한다.

[위에서 아래로 코드 읽기: 내려가기 규칙]
> 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.<br>
> 즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계식 낮아진다.

<br>

#### Switch 문

> 본질적으로 switch 문은 N가지를 처리한다. 불행하게도 switch 문을 완전히 피할 방법은 없다. 하지만 각 switch 문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법은 있다. 물론 다형성(
> pholymorphism)을 이용한다.

> 아마 가장 심각한 문제라면 위 함수와 구조가 동일한 함수가 무한정 존재한다는 사실이다.

`calcualtePay()` 처럼 직원 유형에 따라 다른 값을 계산해 반환하는 함수는 `isPayday()`, `deliverPay()` 등 계속 늘어날 수 있다.

> 가능성은 무한하다. 그리고 모두가 똑같이 유해한 구조다.

> 일반적으로 나는 switch 문을 단 한 번만 참아준다. 다형적 객체를 생성하는 코드 안에서다. 이렇게 상속 관계로 숨긴 후에는 절대로 다른 코드에 노출하지 않는다.

<br>

#### 서술적인 이름을 사용해라!
> "코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다." 한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 이런 원칙을 달성함에 있어 이미 절반은 성공했다. 함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다.

> 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 길고 서술적인 이름이 길고 서술적인 주석보다 좋다. 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다. 그런 다음, 여러 단어를 사용해 함수 기능을 잘 표현하는 이름을 선택한다.

> 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.

> 이름을 붙일 때는 일관성이 있어야 한다. 모듈 내에서 함수 이름은 같은 문구 명사, 동사를 사용한다. <br>
> 문체가 비슷하면 이야기를 순차적으로 풀어가기도 쉬어진다.

#### 함수 인수
> 흔히 우리는 함수에다 인수로 입력을 넘기고 반환값으로 출력을 받는다는 개념에 익숙하다. 대게 함수에서 인수로 결과를 받으리라 기대하지 않는다.

[많이 쓰는 단항 형식]
> 함수에 인수를 1개를 넘기는 이유로 가장 흔한 경우는 두 가지다. 하나는 인수에 질문을 던지는 경우다. boolean fileExists("MyFile")이 좋은 예다. 다른 하나는 인수를 뭔가로 변환해 결과를 반환하는 경우다.

[플래그 인수]
> 함수가 한꺼번에 여러가지를 처리한다고 대놓고 공표하는 셈이니까! 플래그가 참이면 이걸 하고 거짓이면 저걸 한다는 말이니까!

> `renderForSuite()` 와 `renderForSingleTest()` 라는 함수로 나눠야 마땅하다.

[이항 함수]
> `writeField(name)`는 `writeField(outputStream, name)`보다 이해하기 쉽다. <br>
> 후자는 잠시 주춤하며 첫 인수를 무시해야 한다는 사실을 깨닫는 시간이 필요하다. <br>
> 어떤 코드든 절대로 무시하면 안되니까. 무시한 코드에 오류가 숨어드니까.

> 위험이 따른다는 사실을 이해하고 가능하면 단항 함수로 바꾸도록 애써야 한다.

[인수 객체]
> 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다. <br>
> `Circle makeCircle(double x, double y, double radius);` <br>
> `Circle makeCircle(Point center, double radius);` <br>
> 변수를 묶어 넘기려면 이름을 붙여야 하므로 결국은 개념을 표현하게 된다.

[동사와 키워드]
> 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다. 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.

> 마지막 예제는 함수 이름에 키워드를추가하는 형식이다. 즉, 함수 이름에 인수 이름을 넣는다. 예를 들어, assertEquals보다 assertExpectedEqualsActual(expected, actual)이 더 좋다. 그러면 인수 순서를 기억할 필요가 없어진다.

<br>

#### 부수 효과를 일으키지 마라!
> 많은 경우 시간적인 결합(temporal coupling)이나 순서 종속성(order dependency)을 초래한다.

> 이름만 봐서는 세션을 초기화한다는 사실이 드러나지 않는다. 그래서 함수 이름만 보고 함수를 호출하는 사용자는 사용자를 인증하면서 기존 세션 정보를 지워버릴 위험에 처한다.

> 이런 부수 효과가 시간적인 결합을 초개한다. <br>
> 세션을 초기화해도 괜찮은 경우에만 호출이 가능하다 <br>
> 시간적인 결합은 혼란을 일으킨다. 특히 부수 효과로 숨겨진 경우에는 더더욱 혼란이 커진다. 만약 시간적인 결합이 필요하다면 함수 이름에 분명히 명시한다. 목록 3-6은 checkPasswordAndInitializeSession이라는 이름이 훨씬 좋다.

[출력 인수]
> 일반적으로 출력 인수는 피해야 한다. 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 택한다.

#### 명령과 조회를 분리하라!
> 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야한다. 객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나다.

> `if (set("username", "unclebob"))...` <br>
> 함수를 구현한 개발자는 "set"을 동사로 의도했다. 하지만 if문에 넣고 보면 형용사로 느껴진다. <br>
> 진짜 해결책은 명령과 조회를 분리해 혼란을 애초에 뿌리뽑는 방법이다. <br>
> `if (attributeExists("username") { setAttribute("username", "unclebob"); }`

#### 오류 코드보다 예외를 사용하라!
> 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다. 자칫하면 if문에서 명령을 표현식으로 사용하기 쉬운 탓이다. <br>
> `if (deletePage(page) == E_OK)` <br>
> 위 코드는 동사/형용사 혼란을 일으키지 않는 대신 여러 단계로 중첩되는 코드를 야기한다. 오류 코드를 반환하면 호출자는 오류 코드를 곧바로 처리해야 한다는 문제에 부딪힌다.

> 반면 오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.

[Try/Catch 블록 뽑아내기]
> 정상 동작과 오류 처리 동작을 분리하면 코드를 이해하고 수정하기 쉬워진다.

[오류 처리도 한 가지 작업이다.]
> 함수는 '한 가지' 작업만 해야한다. 오류 처리도 '한 가지' 작업에 속한다. 그러므로 오류를 처리하는 함수는 오류만 처리해야 마땅하다.

[Error.java 의존성 자석]
> ```
> public enum Error {
>   OK,
>   INVALID,
>   NO_SUCH,
>   ...
> }
> ```
> 위와 같은 클래스는 의존성 자석(magnet)이다.

> 오류 코드 대신 예외를 사용하면 새 예외는 Exception 클래스에서 패생된다.

#### 반복하지 마라!
> 중복은 문제다. 코드 길이가 늘어날 뿐 아니라 알고리즘이 변화면 네 곳이나 손봐야 하니까. 게다가 어느 한곳이라도 빠뜨리는 바람에 오류가 밸생할 확률도 네 배나 높다.

#### 구조적 프로그래밍
> 데이크스트라는 모든 함수와 함수 내 모든 블록에 입구(entry)와 출구(exit)가 하나만 존재해야 한다고 말했다. 즉, 함수는 return 문이 하나여야 한다는 말이다.

#### 함수는 어떻게 짜죠?
> 나는 그 서투른 코드를 빠짐없이 테스트하는 단위 테스트 케이스도 만든다.

> 그런 다음 나는 코드를 다듬고, 하수를 만들고, 이름을 바꾸고, 중복을 제거한다. 메서드를 줄이고 순서를 바꾼다. 때로는 전체 클래스를 쪼개기도 한다. 이 와중에도 코드는 항상 단위 테스트를 통과한다.

#### 결론
> 대가(master) 프로그래머는 시스템을 (구현할) 프로그램이 아니라 (풀어갈) 이야기로 여긴다. 프로그래밍이라는 수단을 사용해 좀 더 풍부하고 좀 더 표현력이 강한 언어를 만들어 이야기를 풀어간다.

> 진짜 목표는 시스템이라는 이야기를 풀어가는 데 있다는 사실을 명심하기 바란다.