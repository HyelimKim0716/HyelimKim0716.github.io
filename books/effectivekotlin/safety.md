## 1부 좋은 코드
### 1장 안정성
'어떻게 코드를 잘 작성해야 하는가?' 에 대한 견해를 밝히는 여러 책들은 변수, 클래스의 역할을 명확하게 하라고 조언하는데, 이는 가독성을 높이기도 하지만 안전한 프로그램을 만들 수 있는 방법이기 떄문이다. '안정성'은 개발에서 그 어떤 요소보다 가장 중요하게 생각하고 고려해야할 부분이 아닐까? 기본적이지만 가장 중요하기 때문인지 책에서 처음으로 소개하는 챕터는 '안정성' 에 관련된 내용이다. 코틀린은 '안전'하게 개발할 수 있는 최적의 언어이지만, 개발자가 주의깊게 사용하지 않으면 위험해지는 건 금방이다.

#### 아이템1. 가변성을 제한하라
[가변성을 왜 제한해야 하는가]
> 1. 프로그램을 이해하고 디버그하기 힘들어집니다.
> 2. 가변성이 있으면, 코드의 실행을 추론하기 어려워집니다.
> 3. 멀티스레드 프로그램일 때는 적절한 동기화가 필요합니다.
> 4. 테스트하기 어렵습니다.
> 5. 상태 변경이 일어날 때, 이러한 변경을 다른 부분에 알려야 하는 경우가 있습니다.

 여기에서 상태란 'var' 를 사용해 정의하거나 mutable 객체를 사용해 변경할 수 있는 요소를 말한다. 상태를 가지면 막상 사용하는 시점에 이 상태가 어떤 값을 가지고 있는지 알 수 없어 이를 판단하기 위해 변경했던 부분을 tracking 해야한다. 멀티스레드를 활용해 수정하는 경우는 특정 시점에 어떤 값을 가지게 될 지 추측하기 더 어려워진다. 더따라서 변경 가능한 변수를 정의하는 것은 지양하는 것이 좋으며, 꼭 필요한 경우에만 사용해야한다.
 
[코틀린에서 가변성 제한하기]
> * 읽기 전용 프로퍼티(val)
> * 가변 컬렉션과 읽기 전용 컬렉션 구분하기
> * 데이터 클래스의 copy

가변성을 제한하는 방법은 위와 같으나, 값이 정말 불변한다는 의미는 아니다. val 로 정의한다 한들 mutableList 로 mutableList 로 초기화하면 변경이 가능하다.

* 읽기 전용 프로퍼티(val)
```
val list = mutableListOf(1, 2, 3)

var name: String? = "Billie"
var surname: String? = "Eilish"
val fullName: String?
    get() = "$name $surname"
```
val 로 선언하더라도 list 처럼 mutable 한 객체라면 변할 수 있고, name, surname 에 의존적인 fullName 은 get() 시점에 "Billie Eilish" 가 된다는 보장이 없다. 이 떄문에 `if (fullName != null) println(fullName.length)` 처럼 스마트 캐스팅하여 사용할 수도 없다. 

> val 은 읽기 전용 프로퍼티지만, 변경할 수 없음(불변, immutable)을 의미하는 것은 아니라는 것을 기억하기 바랍니다. ... 만약 완전히 변경할 필요가 없다면, final 프로퍼티를 사용하는 것이 좋습니다.

* 가변 컬렉션과 읽기 전용 컬렉션 구분하기



