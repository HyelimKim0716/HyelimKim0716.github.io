### 1장 깨끗한 코드

> 이 책은 좋은 프로그램 작성 요령을 설명하는 책이고 온통 코드들이다. 그리고 좋은 코드와 나쁜 코드를 구분하는 능력도 생긴다. 게다가 좋은 코드를 작성하는 방법도 익힌다. 마지막으로 나쁜 코드를 좋은 코드로 바꾸는 실력도 쌓인다.

<br>

#### 코드가 존재하리라

> 기계가 실행할 정도로 상세하게 요구사항을 명시하는 작업, 바로 이것이 프로그래밍이다.<br>
> 고도로 추상화된 언어나 특정 응용 분야 언어로 기술하는 명세 역시 코드니까!

> 창의력과 직관을 보유한 우리 인간조차도 고객의 막연한 감정만 갖고는 성공적인 시스템을 구현하지 못한다. 지금까지 우리가 요구사항 명세 분야에서 배운 교훈이라면, **제대로 명시한 요구사항은 코드만큼 정형적이며 테스트 케이스로 사용해도 좋다는 사실이다!**
> 궁극적으로 코드는 **요구사항을 표현하는 언어**라는 사실을 명심한다. 요구사항에 더욱 가까운 언어를 만들 수도 있고, 요구사항에서 정형 구조를 뽑아내는 도구를 만들 수도 있다. 하지만 어느 순간에는 정밀한 표현이 필요하다. 그 필요성을 없앨 방법은 없다.

<br>

#### 나쁜 코드

> '고행(wading)' 이라 부른다. 우리는 나쁜 코드를 헤쳐나간다.

> 우리 모두는 자신이 짠 쓰레기 코드를 쳐다보며 나중에 손보겠다고 생각한 경험이 있다. **나중은 결코 오지 않는다.**

<br>

#### 나쁜 코드로 치르는 대가

> 나쁜 코드가 쌓일수록 팀 생산성은 떨어진다.<br>
> 생산성을 증가시키려는 희망을 품고 프로젝트에 인력을 추가로 투입한다.<br>
> 하지만 새 인력은 설계 의도에 맞는 변경과 설계 의도에 반하는 변경을 구분하지 못하며, 새 인력과 팀은 결국 나쁜 코드를 더 많이 양산한다.<br>

[원대한 재설계의 꿈]
> 처음부터 시작해 진정으로 아름다운 작품을 창조할 기회니까.<br>
> 기존 시스템 기능을 모두 제공하는 새 시스템을 내 놓아야 한다. 그뿐만이 아니다. 그동안 기존 시스템에 가해지는 변경도 모두 따라잡아야 한다.

> 방금 한 이야기를 일부라도 겪었다면 시간을 들여 **깨끗한 코드를 만드는 노력이 비용을 절감하는 방법일 뿐만 아니라 전문가로서 살아남는 길**이라는 사실을 인정하리라

[태도]
> 관리자와 마케팅은 약속과 공약을 내걸며 우리에게 정보를 구한다. 우리에게 정보를 구하지 않더라도 우리가 적극적으로 정보를 제공해야 마땅하다. 사용자는 요구사항을 내놓으며 우리에게 현실성을 자문한다. 프로젝트 관리자는 일정을 잡으며 우레에게 도움을 청한다. 우리는 프로젝트를 계획하는 과정에 깊숙히 관여한다. 그러므로 프로젝트 실패는 우리에게도 커다란 책임이 있다. 특히 나쁜 코드가 초래하는 실패에는 더더욱 책임이 크다.

> 일정에 쫓기더라도 대다수 관리자는 좋은 코드를 원한다. 그들이 일정과 요구사항을 강력하게 밀어붙이는 이유는 그것이 그들의 책임이기 때문이다. **좋은 코드를 사수하는 일은 바로 우리 프로그래머들의 책임이다.**

> **나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가답지 못하다.**

[원초적 난제]
> 나쁜 코드가 업무 속도를 늦춘다는 사실을 익히 안다. 그럼에도 모든 프로그래머가 기한을 맞추려면 나쁜 코드를 양산할 수밖에 없다고 느낀다.

> 기한을 맞추는 유일한 방법은, 그러니까 빨리 가는 유일한 방법은, **언제나 코드를 최대한 깨끗하게 유지하는 습관**이다.

[깨끗한 코드라는 예술?]
> "깨끗한 코드를 어떻게 작성할까?" 깨끗한 코드가 무엇인지 모르면 깨끗한 코드를 만들려고 애써봤자 소용이 없다.

> 꺠끗한 코드와 나쁜 코드를 구분할 줄 안다고 깨끗한 코드를 작성할 줄 안다는 뜻은 아니다.

> 깨끗한 코드를 작성하려면 '청결'이라는 힘겹게 습득한 감각을 활용해 자잘한 기법들을 적용하는 절제와 규율이 필요하다. 열쇠는 '코드 감각'이다. 어떤 사람은 코드 감각을 타고난다. 어떤 사람은 투쟁해서 얻어야 한다. '코드 감각'이 있으면 좋은 코드와 나쁜 코드를 구분한다. 그뿐만이 아니다. **절제와 규율을 적용해 나쁜 코드를 좋은 코드로 바꾸는 전략도 파악한다.**<br>
> '코드 감각'이 없는 프로그래머도 때로는 나쁜 모듈을 알아본다. 하지만 그것으로 끝이다. '코드 감각'이 있는 프로그래머는 나쁜 모듈을 보면 좋은 모듈로 개선할 방안을 떠올린다. '코드 감각'으로 최고 방안을 선택한 후 여기서 거기까지 이동하는 경로를 계획한다.<br>
> 다시말해, 깨끗한 코드를 작성하는 프로그래머는 빈 캔버스를 우아한 작품으로 바꿔가는 화가와 같다.

[깨끗한 코드란?]
> **바야네 스트롭스트룹**
> > 논리가 간단해야 버그가 숨어들지 못한다. 의존성을 최대한 줄여야 유지보수가 쉬워진다.

> 나쁜 코드는 나쁜 코드를 '유혹'한다! 흔히 나쁜 코드를 고치면서 오히려 더 나쁜 코드를 만든다는 뜻이다. <br><br>
> 실용주의 프로그래머 데이브 토마스와 앤디 헌트는 같은 이야기를 다르게 표현했는데, 그들은 깨진 창문이라는 비유를 사용했다. <br><br>
> 바야네는 철저한 오류 처리도 언급한다. 세세한 사항까지 꼼꼼하게 신경쓰라는 말이다. <br><br>
> 깨끗한 코드는 세세한 사항까지 꼼꼼하게 처리하는 코드다. <br><br>
> 나쁜 코드는 너무 많은 일을 하려 애쓰다가 의도가 뒤섞이고 목적이 흐려진다. 깨끗한 코드는 한가지에 '집중'한다. 각 함수와 클래스와 모듈은 주변 상황에 현혹되거나 오염되지 않은 채 한길만 걷는다.

<br>

> **그래디 부치**
> > 깨끗한 코드는 잘 쓴 문장처럼 읽힌다.

> 그래디는 비야네와 흡사한 의견을 표명하지만 가독성을 강조한다. <br><br>
> 코드는 추측이 아니라 사실에 기반해야 한다. 반드시 필요한 내용만 담아야 한다. 코드를 읽는 사람에게 프로그래머가 단호하다는 인상을 줘야 한다.

<br>

> **큰 데이브 토마스**
> > 깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다. 단위 테스트 케이스와 인수 테스트 케이스가 존재한다. 깨끗한 코드에는 의미 있는 이름이 붙는다. 특정 목적을 달성하는 방법은 (여러 가지가 아니라) 하나만 제공한다. 의존성은 최소이며 각 의존성을 명확히 정의한다. API는 명확하며 최소로 줄였다.

> 데이브는 깨끗한 코드란 다른 사람이 고치기 쉽다고 단언한다. <br><br>
> 작을수록 좋다. <br><br>
> 인간이 읽기 좋은 코드를 작성하라는 말이다.

<br>

> **마이클 페더스**
> > **깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다.** 고치려고 살펴봐도 딱히 손 댈 곳이 없다. 작성자가 이미 모든 사항을 고려했으므로. 고칠 궁리를 하다보면 언제나 제자리로 돌아온다.

<br>

> **론 제프리스**
> > 같은 작업을 여러 차례 반복한다면 코드가 아이디어를 제대로 표현하지 못한다는 증거다. 나는 문제의 아이디어를 찾아내 좀 더 명확하게 표현하려 애쓴다. <br>
> > 내게 있어 표현력은 의미 있는 이름을 표함한다.<br>
> > 나는 여러 기능을 수행하는 객체나 메서드도 찾는다. 객체가 여러 기능을 수행한다면 여러 객체로 나눈다. 메서드가 여러 기능을 수행한다면 메서드 추출 리팩터링 기법을 적용해 기능을 명확히 기술하는 메서드 하나와 기능을 실제로 수행하는 메서드 여러 개로 나눈다.<br>
> > 중복과 표현력만 신경 써도 (내가 생각하는) 깨끗한 코드라는 목표에 성큼 다가선다.<br>
> > 추상 메서드나 추상 클래스를 만들어 실제 구현을 감싼다.<br>
> > 다른 코드는 추상 클래스나 추상 메서드가 제공하는 기능을 사용하므로 실제 구현은 언제든지 바꿔도 괜찮다.<br>
> > 중복 줄이기, 표현력 높이기, 초반부터 간단한 추상화 고려하기. 내게는 이 세 가지가 깨끗한 코드를 만드는 비결이다.<br>

<br>

> **워드 커닝햄**
> > 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.

> 코드를 독해하느라 머리를 쥐어짤 필요가 없어야 한다. 읽으면서 짐작한 대로 코드가 돌아가는 코드가 깨끗한 코드다. 명백하고 단순해 마음이 끌리는 코드가 깨끗한 코드다.<br><br>
> 모든 뛰어난 설계처럼 설계자가 코드를 어이 없을 정도로 단순하게 설계했기 때문이다.<br><br>
> 언어를 단순하게 보이도록 만드는 책임이 우리에게 있다는 뜻이다!<br><br>
> 하지만 프로그램을 단순하게 보이도록 만드는 열쇠는 언어가 아니다. 언어를 단순하게 보이도록 만드는 열쇠는 프로그래머다!

<br>

#### 우리는 저자다
> 다음에 코드를 짤 때는 자신이 저자라는 사실을, 여러분의 노력을 보고 판단을 내릴 독자가 있다는 사실을 기억하기 바란다.

> 코드를 읽는 시간 대 코드를 짜는 시간 비율이 10 대 1을 훌쩍 넘는다. 새 코드를 짜면서 우리는 끊임없이 기존 코드를 읽는다. <br>
> 비율이 이렇게 높으므로 읽기 쉬운 코드가 매우 중요하다.<br>
> 하지만 기존 코드를 읽어야 새 코드를 짜므로 읽기 쉽게 만들면 사실은 짜기도 쉬워진다.<br>

> 주변 코드를 읽지 않으면 새 코드를 짜지 못한다.<br>
> 그러므로 급하다면, 서둘러 끝내려면, 쉽게 짜려면, 읽기 쉽게 만들면 된다.

<br>

#### 보이스카우트 규칙
> 잘 짠 코드가 전부는 아니다. 시간이 지나도 언제나 깨끗하게 유지해야 한다. 시간이 지나면서 엉망으로 전락하는 코드가 한둘이 아니다. 그러므로 우리는 적극적으로 코드의 퇴보를 막아야 한다.

> 변수 이름 하나를 개선하고, 조금 긴 함수를 분할하고, 약간의 중복을 제거하고, 복잡한 if문 하나를 정리하면 충분하다.<br>
> 시간이 지날수록 코드가 좋아지는 프로젝트에서 작업한다고 상상해보라! 전문가라면 너무도 당연하지 않은가! 지속적인 개선이야말로 전문가 정신의 본질이 아니던가?

<br>

#### 결론
> 예술에 대한 책을 읽는다고 예술가가 된다는 보장은 없다.

> 예술에 대한 책과 마찬가지로 이 책 역시 세세한 정보로 가득하다. 코드도 많다. 좋은 코드도 소개하고 나쁜 코드도 소개한다. 나쁜 코드를 좋은 코드로 바꾸는 방법도 소개한다. 다양한 경험적 교훈과 체계와 절차와 기법도 열거한다. 예제도 무수히 많이 보여준다. 나머지는 여러분에게 달렸다.

<br>
<br>

'1장 깨끗한 코드'는 유명 프로그래머들의 '깨끗한 코드'에 대한 정의가 주를 이룬다. 모든 내용이 공감되고, 기억하고 싶었다. 앞으로 이어질 깨끗한 코드를 짜는 방법이 어렵고 방대하여 중간에 포기하고 싶어지더라도 '깨끗한 코드' 를 작성할 줄 알게 되었을 때를 상상하며 포기하지 말라고 미리 다독여준 Chapter 였다.<br>
가장 공감이 갔던 부분은 ‘마이클 페더스’ 와 ‘워드 커닝햄’ 의 의견이었다. ‘마이클 페더스’ 는 “깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다” 라고 이야기했고, '워드 커닝햄’ 은 “코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다.” 고 한다. 주로 잘 짰다고 여겨지는 코드들은 깔끔 그 자체다. 메서드와 로직이 매칭되어 이해하기 쉽고 수정하기 아까울 정도이다.<br>

나는 주로 코드를 작성할 때 의존도를 낮추고, 변수/함수/클래스/모듈 등의 역할을 명확하게 하려고한다. 그렇게 구현하려면 네이밍이 명확해야 할 것이고, 가독성도 높아야 하며, 테스트 코드도 쉽게 짤 수 있어야 한다.

리멤버 안드로이드 프로젝트에서 '깨끗한 코드' 로 예를 들 수 있을만한 부분은 CleanArchitecture 를 안드로이드 프로젝트에 맞게 적용한 부분인 것 같다. domain, data, app(presentation) 모듈로 분리하여, 관심사를 분리하고 의존성도를 최소화하려고 노력했다. domain 모듈에서는 

<br>
공감이 되었던 부분 중 다른 하나는 '나쁜 코드로 치르는 대가 > 태도' 였는데, 관리자는 우리에게 요구사항을 내놓으며 현실성을 자문하고, 일정을 잡으며 도움을 청한다는 부분이었다. 기존 코드가 나쁘다는 핑계로, 일정이 빡빡하다는 핑계로, 레거시를 그대로 두며 레거시를 만들어낸 경우는 자주 있었다. 하지만 일정은 개발자가 주도하여 결정한다. 더 이상 코드가 덕지덕지 붙으면 앞으로 보고싶지 않은 코드가 될 것 같다면 일부 수정할 수 있는 시간을 고려하여 일정을 결정할 수 있다. (물론 급작스레 맞닥뜨린 문제로 코드를 수정할 새도 없이 일정이 가까워 질 수 있는 가능성도 충분하다) 그렇다고 프로젝트 전체를 뒤집어 엎을 수는 없다. '원대한 재설계의 꿈' 처럼 시간이 오래 걸리고 결국 잘못된 선택이었음을 깨닳을 테니까. 수정이 필요하다면 feature 개발하면서 검수가 가능한 영역까지이고, 더 큰 수정이 필요하다면 scope 을 쪼개 진행하는 것이 좋다. (일정 산출하는데는 경험도 큰 역할 한다.)
<br>

책을 다 읽고 나면 어떤 코드가 좋은 코드인지, 나쁜 코드인지 판단하고 이를 어떻게 수정할 수 있는지 판단할 수 있는 능력이 생기면 좋겠다.

